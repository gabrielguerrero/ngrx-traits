import {
  Prettify,
  SignalStoreFeature,
  signalStoreFeature,
  SignalStoreFeatureResult,
  StateSignals,
  withMethods,
  WritableStateSource,
} from '@ngrx/signals';

import {
  combineFunctions,
  combineFunctionsInObject,
  OverridableFunction,
} from '../util';
import { Event, EventCreator, EventType } from './with-event-handler.model';

const ON_EVENT = '__onEvent';

/**
 * @experimental
 * Adds an event handler to the store, allowing the store to listen to events and react to them.
 * This helps with the communications between different store feature functions, normally a store feature can only
 * call methods generated by other store featured if it is declared before. With event handlers, you can send events
 * to other store features, and they can react to them regardless of the order of declaration. This is useful for example between
 * the filter and pagination store features, filter fires an event when the filter is changed and the pagination store
 * feature can listen to it and reset the current page back to 0, by using  withEventHandler pagination avoids creating a dependency
 * on the filter store feature, and the order in which they get declared won't affect the communication .
 *
 * @param eventHandlerFactory
 *
 * @example
 *
 *     const increment = createEvent('[Counter] Increment');
 *     const decrement = createEvent('[Counter] Decrement');
 *     const add = createEvent('[Counter] Add', props<{ value: number }>());
 *     const Store = signalStore(
 *       withState({ count: 0 }),
 *       withEventHandler((state) => [
 *         onEvent(increment, () => {
 *           patchState(state, { count: state.count() + 1 });
 *         }),
 *         onEvent(decrement, () => {
 *           patchState(state, { count: state.count() - 1 });
 *         }),
 *       ]),
 *       withMethods((state) => {
 *         return {
 *           // this test we can send events to things defined after this method
 *           add5: () => broadcast(state, add({ value: 5 })),
 *         };
 *       }),
 *       withEventHandler((state) => [
 *         onEvent(add, ({ value }) => {
 *           patchState(state, { count: state.count() + value });
 *         }),
 *       ]),
 *       withMethods((state) => {
 *         return {
 *           increment: () => broadcast(state, increment()),
 *           decrement: () => broadcast(state, decrement()),
 *         };
 *       }),
 *     );
 */
export function withEventHandler<Input extends SignalStoreFeatureResult>(
  eventHandlerFactory?: (
    store: Prettify<
      StateSignals<Input['state']> &
        Input['props'] &
        Input['methods'] &
        WritableStateSource<Prettify<Input['state']>>
    >,
  ) => EventHandlersTypes<any>[],
): SignalStoreFeature<Input, Input> {
  return signalStoreFeature(
    withMethods((store) => {
      const handlersArray = eventHandlerFactory?.(store as any);
      const eventHandler = handlersArray
        ? (event: Event) => {
            handlersArray.forEach((h) => {
              h.types.includes(event.type) && h.handlers(event);
            });
          }
        : undefined;

      return combineFunctionsInObject(
        {
          [ON_EVENT]: eventHandler,
        },
        store,
      ) as any;
    }),
  ) as any;
}
export function broadcast<A extends Event>(
  store: Record<string | symbol, unknown>,
  event: A,
) {
  if (!store[ON_EVENT]) {
    throw new Error(
      'No event handler found, you must add withEventHandler to use broadcast',
    );
  }
  (store[ON_EVENT] as OverridableFunction)(event);
}

export interface OnEvent<Creators extends readonly EventCreator[]> {
  (event: EventType<Creators[number]>): void;
}
export interface EventHandlersTypes<Creators extends readonly EventCreator[]> {
  handlers: OnEvent<Creators>;
  types: ExtractEventTypes<Creators>;
}
type ExtractEventTypes<Creators extends readonly EventCreator[]> = {
  [Key in keyof Creators]: Creators[Key] extends EventCreator<infer T>
    ? T
    : never;
};
export function onEvent<
  // Event creators
  Creators extends readonly EventCreator[],
>(
  ...args: [...creators: Creators, handler: OnEvent<Creators>]
): EventHandlersTypes<Creators> {
  const handlers = args.pop() as unknown as OnEvent<Creators>;
  const types = (args as unknown as Creators).map(
    (creator) => creator.type,
  ) as unknown as ExtractEventTypes<Creators>;
  return { handlers, types };
}
